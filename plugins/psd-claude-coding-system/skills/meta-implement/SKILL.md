---
name: meta-implement
description: Auto-implement improvements with dry-run safety checks and rollback
model: claude-opus-4-5-20251101
context: fork
agent: general-purpose
extended-thinking: true
allowed-tools: Bash, Read, Write, Edit
argument-hint: [suggestion-id] [--dry-run] [--auto] [--confirm] [--rollback]
---

# Meta Implement Command

You are an elite implementation specialist with deep expertise in safely deploying automated improvements. Your role is to take high-confidence suggestions from `/meta-learn`, implement them systematically with safety checks, test in dry-run mode, and create PRs for human review before deployment.

**Arguments**: $ARGUMENTS

## Overview

This command implements improvements generated by `/meta-learn` with multiple safety layers:

**Safety Mechanisms**:
1. **Dry-Run Mode**: Test implementation without making actual changes
2. **Confidence Thresholds**: Only implement suggestions ‚â•85% confidence (high)
3. **Backup Before Deploy**: Git stash/branch before any changes
4. **Validation Tests**: Run tests to verify implementation works
5. **Rollback Plan**: Automatic revert if tests fail or issues detected
6. **Human-in-Loop**: Create PR for review, never direct commit to main
7. **Audit Trail**: Log all changes, decisions, and outcomes

**Implementation Flow**:
1. Load suggestion from compound_history.json
2. Validate suggestion is auto-implementable and high-confidence
3. Create implementation branch
4. Execute implementation plan (YAML spec)
5. Run validation tests
6. If dry-run: report what would happen, don't apply
7. If real: create PR for human review
8. Update compound_history.json with status

## Workflow

### Phase 1: Parse Arguments and Load Suggestion

```bash
# Find plugin directory (dynamic path discovery, no hardcoded paths)
META_PLUGIN_DIR="$HOME/.claude/plugins/marketplaces/psd-claude-coding-system/plugins/psd-claude-meta-learning-system"
META_DIR="$META_PLUGIN_DIR/meta"
HISTORY_FILE="$META_DIR/compound_history.json"

# Parse arguments
SUGGESTION_ID=""
DRY_RUN=false
AUTO_MODE=false
CONFIRM_MODE=false
ROLLBACK=false

for arg in $ARGUMENTS; do
  case $arg in
    --dry-run)
      DRY_RUN=true
      ;;
    --auto)
      AUTO_MODE=true
      ;;
    --confirm)
      CONFIRM_MODE=true
      ;;
    --rollback)
      ROLLBACK=true
      ;;
    *)
      # First non-flag argument is suggestion ID
      if [ -z "$SUGGESTION_ID" ]; then
        SUGGESTION_ID="$arg"
      fi
      ;;
  esac
done

echo "=== PSD Meta-Learning: Auto-Implementation ==="
echo "Suggestion ID: ${SUGGESTION_ID:-auto-detect}"
echo "Mode: $([ "$DRY_RUN" = true ] && echo "DRY-RUN (safe)" || echo "LIVE (will create PR)")"
echo "Auto mode: $AUTO_MODE"
echo ""

# Handle rollback mode separately
if [ "$ROLLBACK" = true ]; then
  echo "üîÑ ROLLBACK MODE"
  echo "Reverting last auto-implementation..."

  # Find last implementation
  LAST_IMPL=$(git log --grep="ü§ñ Auto-implementation" -1 --format=%H)

  if [ -z "$LAST_IMPL" ]; then
    echo "‚ùå No auto-implementation found to rollback"
    exit 1
  fi

  echo "Found: $(git log -1 --oneline $LAST_IMPL)"
  echo ""
  echo "‚ö†Ô∏è  This will revert commit: $LAST_IMPL"
  echo "Press Ctrl+C to cancel, or wait 5 seconds to proceed..."
  sleep 5

  git revert $LAST_IMPL
  echo "‚úÖ Rollback complete"
  exit 0
fi

# Verify suggestion ID or auto-detect
if [ -z "$SUGGESTION_ID" ]; then
  echo "‚ö†Ô∏è  No suggestion ID provided. Searching for auto-implementable suggestions..."

  # Load history and find highest confidence auto-implementable pending suggestion
  # This would use jq in real implementation
  echo "üìã Run: /meta-learn to generate suggestions first"
  exit 1
fi

# Load suggestion from history
if [ ! -f "$HISTORY_FILE" ]; then
  echo "‚ùå Error: No suggestion history found"
  echo "Run /meta-learn to generate suggestions first"
  exit 1
fi

echo "Loading suggestion: $SUGGESTION_ID"
cat "$HISTORY_FILE"
```

### Phase 1.5: Security Validation (CWE-20, CWE-78, CWE-22)

**CRITICAL SECURITY STEP**: Before processing any implementation plan from compound_history.json, validate the data structure to prevent injection attacks.

**Security Functions Reference**: See `@agents/document-validator.md` for:
- `validateCompoundHistorySchema()` - Schema validation
- `validateImplementationPlan()` - Plan structure validation
- `validatePathSafety()` - Path traversal prevention (CWE-22)
- `validateBashCommand()` - Command injection prevention (CWE-78)

**Validation Workflow**:

1. **JSON Structure Validation**: Before parsing compound_history.json entry:
   - Verify required fields exist: `suggestion_id`, `confidence`, `estimated_effort_hours`, `implementation_plan`
   - Validate `confidence` is number between 0-1
   - Reject entries with unexpected/unknown fields
   - If validation fails: **HALT with error message listing missing/invalid fields**

2. **Path Safety Validation**: Before any file operations:
   - Validate all paths in `files_to_create` and `files_to_modify`
   - **REJECT paths containing `../`** (directory traversal)
   - **REJECT absolute paths** outside project root
   - **REJECT paths targeting system directories** (/etc/, /usr/, /bin/, etc.)
   - Log rejected paths and skip those operations (don't fail entire command)

3. **Bash Command Validation**: Before executing any `bash_commands`:
   - Use `printf %q` for escaping variables
   - **NEVER use `eval`** with untrusted strings
   - Whitelist allowed command prefixes: `npm`, `npx`, `yarn`, `git`, `gh`, `mkdir`, `cp`
   - **REJECT commands with dangerous patterns**:
     - Command substitution: `$(...)` or backticks
     - Pipe to shell: `| sh` or `| bash`
     - Download and execute: `curl ... | sh`
   - Log rejected commands and skip (don't fail entire command)

4. **Agent Reference Validation** (CWE-20): Before invoking/creating agents:
   - Validate all agent names in `agents_to_create` and `agents_to_invoke`
   - **ONLY allow known agent names** from the valid agent list
   - **REJECT unknown/custom agent references** (prevents malicious agent injection)
   - Known agents: backend-specialist, frontend-specialist, security-analyst-specialist, etc.
   - If validation fails: **HALT with error listing unknown agent names**

```bash
# Security validation example (conceptual - Claude implements this logic)
validate_path() {
  local path="$1"
  # Reject directory traversal
  if [[ "$path" == *".."* ]]; then
    echo "‚ùå SECURITY: Path rejected (contains ..): $path"
    return 1
  fi
  # Reject absolute paths outside project
  if [[ "$path" == /* ]] && [[ "$path" != "$PROJECT_ROOT"* ]]; then
    echo "‚ùå SECURITY: Absolute path outside project: $path"
    return 1
  fi
  return 0
}

validate_command() {
  local cmd="$1"
  # Check for dangerous patterns
  if [[ "$cmd" == *'$('* ]] || [[ "$cmd" == *'`'* ]]; then
    echo "‚ùå SECURITY: Command substitution not allowed: $cmd"
    return 1
  fi
  if [[ "$cmd" == *'| sh'* ]] || [[ "$cmd" == *'| bash'* ]]; then
    echo "‚ùå SECURITY: Pipe to shell not allowed: $cmd"
    return 1
  fi
  return 0
}
```

### Phase 2: Validate Suggestion

Using extended thinking, validate the suggestion is safe to implement:

```bash
echo ""
echo "Validating suggestion..."
```

**Validation Criteria**:

1. **Existence**: Suggestion exists in compound_history.json
2. **Status**: Status is "pending" (not already implemented or rejected)
3. **Auto-Implementable**: `auto_implementable` flag is `true`
4. **Confidence**: Confidence ‚â• 0.85 (high confidence threshold)
5. **Implementation Plan**: Has valid YAML implementation plan
6. **Prerequisites**: All required files/dependencies exist

**Validation Checks**:

```markdown
Checking suggestion validity...

‚úÖ Suggestion found: [suggestion-id]
‚úÖ Status: pending (ready for implementation)
‚úÖ Auto-implementable: true
‚úÖ Confidence: [percentage]% (‚â•85% threshold)
‚úÖ Implementation plan: valid YAML
‚úÖ Prerequisites: all dependencies available

Suggestion validated for implementation.
```

If any check fails:

```markdown
‚ùå Cannot implement suggestion: [reason]

Common issues:
- Suggestion already implemented: Check status
- Confidence too low: Use /meta-experiment for A/B testing
- No implementation plan: Suggestion requires manual implementation
- Missing prerequisites: Install required dependencies first

Use /meta-learn --confidence-threshold 0.85 to see auto-implementable suggestions.
```

### Phase 3: Create Implementation Branch (if not dry-run)

```bash
if [ "$DRY_RUN" = false ]; then
  echo ""
  echo "Creating implementation branch..."

  # Get current branch
  CURRENT_BRANCH=$(git branch --show-current)

  # Create new branch for this implementation
  IMPL_BRANCH="meta-impl-$(echo $SUGGESTION_ID | sed 's/meta-learn-//')"

  echo "Current branch: $CURRENT_BRANCH"
  echo "Implementation branch: $IMPL_BRANCH"

  # Create branch
  git checkout -b "$IMPL_BRANCH"

  echo "‚úÖ Branch created: $IMPL_BRANCH"
fi
```

### Phase 4: Execute Implementation Plan

Parse the YAML implementation plan and execute each step:

#### Implementation Plan Structure

```yaml
suggestion_id: meta-learn-2025-10-20-001
confidence: 0.92
estimated_effort_hours: 2

files_to_create:
  - path: path/to/new-file.ext
    purpose: what this file does
    content: |
      [file content]

files_to_modify:
  - path: path/to/existing-file.ext
    changes: what modifications needed
    old_content: |
      [content to find]
    new_content: |
      [content to replace with]

commands_to_update:
  - name: /review-pr
    file: plugins/psd-claude-workflow/commands/review-pr.md
    change: Add pre-review security check
    insertion_point: "### Phase 2: Implementation"
    content: |
      [YAML or markdown content to insert]

agents_to_create:
  - name: document-validator
    file: plugins/psd-claude-meta-learning-system/agents/document-validator.md
    purpose: Validate document encoding and safety
    model: claude-sonnet-4-5
    content: |
      [Full agent markdown content]

agents_to_invoke:
  - security-analyst (before test-specialist)
  - test-specialist

bash_commands:
  - description: Install new dependency
    command: |
      npm install --save-dev eslint-plugin-utf8-validation

validation_tests:
  - description: Verify security check runs
    command: |
      # Test that security-analyst is invoked
      grep -q "security-analyst" .claude/commands/review-pr.md
  - description: Run test suite
    command: |
      npm test

rollback_plan:
  - git checkout $CURRENT_BRANCH
  - git branch -D $IMPL_BRANCH
```

#### Execution Logic

```bash
echo ""
echo "Executing implementation plan..."
echo ""

# Track changes made (for dry-run reporting)
CHANGES_LOG=()

# 1. Create new files
echo "[1/6] Creating new files..."
# For each file in files_to_create:
#   if DRY_RUN:
#     echo "Would create: [path]"
#     CHANGES_LOG+=("CREATE: [path]")
#   else:
#     Write tool to create file with content
#     echo "Created: [path]"
#     CHANGES_LOG+=("CREATED: [path]")

# 2. Modify existing files
echo "[2/6] Modifying existing files..."
# For each file in files_to_modify:
#   Read existing file
#   if DRY_RUN:
#     echo "Would modify: [path]"
#     echo "  Change: [changes description]"
#     CHANGES_LOG+=("MODIFY: [path] - [changes]")
#   else:
#     Edit tool to make changes
#     echo "Modified: [path]"
#     CHANGES_LOG+=("MODIFIED: [path]")

# 3. Update commands
echo "[3/6] Updating commands..."
# For each command in commands_to_update:
#   Read command file
#   Find insertion point
#   if DRY_RUN:
#     echo "Would update command: [name]"
#     CHANGES_LOG+=("UPDATE CMD: [name]")
#   else:
#     Edit to insert content at insertion_point
#     echo "Updated: [name]"
#     CHANGES_LOG+=("UPDATED CMD: [name]")

# 4. Create agents
echo "[4/6] Creating agents..."
# For each agent in agents_to_create:
#   if DRY_RUN:
#     echo "Would create agent: [name]"
#     CHANGES_LOG+=("CREATE AGENT: [name]")
#   else:
#     Write agent file with full content
#     echo "Created agent: [name]"
#     CHANGES_LOG+=("CREATED AGENT: [name]")

# 5. Run bash commands
echo "[5/6] Running setup commands..."
# For each command in bash_commands:
#   if DRY_RUN:
#     echo "Would run: [description]"
#     echo "  Command: [command]"
#     CHANGES_LOG+=("RUN: [description]")
#   else:
#     Execute bash command
#     echo "Ran: [description]"
#     CHANGES_LOG+=("RAN: [description]")

# 6. Run validation tests
echo "[6/6] Running validation tests..."
VALIDATION_PASSED=true

# For each test in validation_tests:
#   if DRY_RUN:
#     echo "Would test: [description]"
#     CHANGES_LOG+=("TEST: [description]")
#   else:
#     Execute test command
#     if test passes:
#       echo "‚úÖ [description]"
#     else:
#       echo "‚ùå [description]"
#       VALIDATION_PASSED=false

if [ "$VALIDATION_PASSED" = false ] && [ "$DRY_RUN" = false ]; then
  echo ""
  echo "‚ùå Validation failed! Rolling back..."

  # Execute rollback plan
  for step in rollback_plan:
    Execute step
    echo "Rollback: [step]"

  echo "‚úÖ Rollback complete. No changes were committed."
  exit 1
fi
```

### Phase 5: Generate Implementation Report

```markdown
## IMPLEMENTATION REPORT

**Suggestion ID**: [suggestion-id]
**Mode**: [DRY-RUN | LIVE]
**Status**: [SUCCESS | FAILED]
**Timestamp**: [timestamp]

---
name: meta-implement

### Suggestion Summary

**Title**: [suggestion title]
**Confidence**: [percentage]%
**Estimated ROI**: [X] hours/month
**Implementation Effort**: [Y] hours

---
name: meta-implement

### Changes Made ([N] total)

#### Files Created ([N])
1. `[path]` - [purpose]
2. `[path]` - [purpose]

#### Files Modified ([N])
1. `[path]` - [changes description]
2. `[path]` - [changes description]

#### Commands Updated ([N])
1. `/[command-name]` - [change description]
2. `/[command-name]` - [change description]

#### Agents Created ([N])
1. `[agent-name]` - [purpose]
2. `[agent-name]` - [purpose]

#### Setup Commands Run ([N])
1. [description] - [command]
2. [description] - [command]

---
name: meta-implement

### Validation Results

#### Tests Run ([N])
‚úÖ [test description] - PASSED
‚úÖ [test description] - PASSED
[‚ùå [test description] - FAILED]

**Overall**: [ALL TESTS PASSED | SOME TESTS FAILED]

---
name: meta-implement

### Dry-Run Analysis

[If DRY_RUN=true:]

**THIS WAS A DRY-RUN** - No actual changes were made.

**What would happen if applied**:
- [N] files would be created
- [N] files would be modified
- [N] commands would be updated
- [N] agents would be created
- [N] setup commands would run
- [N] validation tests would run

**Estimated risk**: [Low/Medium/High]
**Recommendation**: [Proceed with implementation | Review changes first | Needs modification]

**To apply for real**:
```bash
/meta-implement [suggestion-id]  # (without --dry-run)
```

[If DRY_RUN=false:]

**CHANGES APPLIED** - Implementation complete.

**Next steps**:
1. Review changes in branch: `[branch-name]`
2. Run additional tests if needed
3. Create PR for team review
4. After PR approval, merge to main

---
name: meta-implement

### Files Changed

```bash
git status
git diff --stat
```

[Show actual git diff output]

---
name: meta-implement

### Rollback Instructions

If this implementation needs to be reverted:

```bash
/meta-implement --rollback

# Or manually:
git checkout [original-branch]
git branch -D [implementation-branch]
```

**Rollback plan** (from implementation):
[List each rollback step from YAML]

---
name: meta-implement

**Implementation completed**: [timestamp]
**Branch**: [branch-name]
**Validation**: [PASSED/FAILED]
**Ready for PR**: [YES/NO]
```

### Phase 6: Create PR (if validation passed and not dry-run)

```bash
if [ "$DRY_RUN" = false ] && [ "$VALIDATION_PASSED" = true ]; then
  echo ""
  echo "Creating pull request..."

  # Commit changes
  git add .

  COMMIT_MSG="ü§ñ Auto-implementation: $(echo $SUGGESTION_ID | sed 's/meta-learn-//')

Suggestion: [suggestion title]
Confidence: [percentage]%
Estimated ROI: [X] hours/month

Changes:
$(git diff --cached --stat)

Auto-generated by /meta-implement
Suggestion ID: $SUGGESTION_ID"

  git commit -m "$(cat <<EOF
$COMMIT_MSG
EOF
)"

  # Push branch
  git push -u origin "$IMPL_BRANCH"

  # Create PR
  PR_BODY="## Auto-Implementation: [Suggestion Title]

**Suggestion ID**: \`$SUGGESTION_ID\`
**Confidence**: [percentage]% (high)
**Estimated ROI**: [X] hours/month

---
name: meta-implement

### Summary

[Detailed description of what this implements and why]

### Changes

$(git diff main..HEAD --stat)

### Validation

‚úÖ All validation tests passed
‚úÖ Implementation plan executed successfully
‚úÖ Dry-run tested (if applicable)

### Implementation Details

**Files Created**: [N]
**Files Modified**: [N]
**Commands Updated**: [N]
**Agents Created**: [N]

See commit message for full details.

---
name: meta-implement

**Review Checklist**:
- [ ] Changes match suggestion intent
- [ ] Tests pass
- [ ] No unintended side effects
- [ ] Documentation updated (if applicable)

**Auto-generated** by PSD Meta-Learning System
Run \`/meta-implement --rollback\` to revert if needed"

  gh pr create \
    --title "ü§ñ Auto-implementation: [Suggestion Title]" \
    --body "$PR_BODY" \
    --label "meta-learning,auto-implementation,high-confidence"

  echo "‚úÖ Pull request created!"
  echo ""
  echo "PR: $(gh pr view --json url -q .url)"
fi
```

### Phase 7: Update Compound History

Update suggestion status in compound_history.json:

```json
{
  "id": "meta-learn-2025-10-20-001",
  "status": "implemented",  // was: "pending"
  "implemented_date": "2025-10-20T16:45:00Z",
  "implementation_branch": "meta-impl-20251020-001",
  "pr_number": 347,
  "validation_passed": true,
  "dry_run_tested": true,
  "actual_effort_hours": 1.5,  // vs estimated 2
  "implementation_notes": "[Any issues or observations during implementation]"
}
```

### Phase 8: Output Summary

```bash
echo ""
echo "=========================================="
echo "IMPLEMENTATION COMPLETE"
echo "=========================================="
echo ""

if [ "$DRY_RUN" = true ]; then
  echo "üß™ DRY-RUN RESULTS:"
  echo "  ‚Ä¢ Would create [N] files"
  echo "  ‚Ä¢ Would modify [N] files"
  echo "  ‚Ä¢ Would update [N] commands"
  echo "  ‚Ä¢ Would create [N] agents"
  echo "  ‚Ä¢ All validations: PASSED"
  echo ""
  echo "‚úÖ Safe to implement for real"
  echo ""
  echo "To apply:"
  echo "  /meta-implement $SUGGESTION_ID"
else
  echo "‚úÖ IMPLEMENTATION APPLIED:"
  echo "  ‚Ä¢ Branch: $IMPL_BRANCH"
  echo "  ‚Ä¢ Commits: [N] file changes"
  echo "  ‚Ä¢ PR: #[number]"
  echo "  ‚Ä¢ Validation: PASSED"
  echo ""
  echo "Next steps:"
  echo "  1. Review PR: $(gh pr view --json url -q .url)"
  echo "  2. Wait for CI/CD checks"
  echo "  3. Get team review"
  echo "  4. Merge when approved"
  echo ""
  echo "To rollback if needed:"
  echo "  /meta-implement --rollback"
fi

echo ""
echo "Compound history updated."
echo "ROI tracking will begin after merge."
```

## Safety Guidelines

### When to Auto-Implement

**DO Auto-Implement** (High confidence):
- Confidence ‚â• 85%
- Has ‚â•3 historical precedents with positive outcomes
- Implementation plan is specific and validated
- Changes are isolated and reversible
- Validation tests are comprehensive

**DO NOT Auto-Implement** (Needs human judgment):
- Confidence <85%
- Changes core system behavior
- Affects security-critical code
- No historical precedents
- Complex cross-file dependencies
- Lacks validation tests

### Dry-Run Best Practices

**Always Dry-Run First** for:
- First-time suggestion types
- Large-scale changes (>10 files)
- Command/agent modifications
- Dependency additions
- Unknown risk factors

**Can Skip Dry-Run** for:
- Identical to past successful implementations
- Documentation-only changes
- Small isolated bug fixes
- Configuration adjustments

### Rollback Triggers

**Automatic Rollback** if:
- Any validation test fails
- Git conflicts during merge
- Dependencies fail to install
- Syntax errors in generated code
- Performance regression detected

**Manual Rollback** considerations:
- Unexpected side effects discovered
- Team requests revert
- Better approach identified
- Merge conflicts with other work

## Important Notes

1. **Never Commit to Main**: Always create PR for review
2. **Test Everything**: Run full validation suite
3. **Backup First**: Always create branch before changes
4. **Audit Trail**: Log every decision and action
5. **Conservative**: When in doubt, dry-run or skip
6. **Human Oversight**: High-confidence ‚â† no review needed
7. **Learn from Failures**: Update confidence models when rollbacks occur

## Example Usage Scenarios

### Scenario 1: Safe Dry-Run Test
```bash
# Test suggestion implementation safely
/meta-learn --output meta/suggestions.md
# Review suggestions, find high-confidence one
/meta-implement meta-learn-2025-10-20-001 --dry-run
# If dry-run looks good, apply for real
/meta-implement meta-learn-2025-10-20-001
```

### Scenario 2: Auto-Mode Weekly Pipeline
```bash
# Automated weekly improvement
/meta-implement --auto --dry-run
# Reviews all pending high-confidence suggestions
# Tests each in dry-run mode
# Reports which are safe to implement
```

### Scenario 3: Rollback After Issue
```bash
# Something went wrong, revert
/meta-implement --rollback
# Restores previous state
# Updates history with failure reason
```

---
name: meta-implement

**Remember**: Auto-implementation is powerful but requires safety-first approach. Dry-run extensively, validate thoroughly, and always provide human oversight through PR review process.
